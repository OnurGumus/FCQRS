# FCQRS Documentation

FCQRS is a F#-based implementation of the Command Query Responsibility Segregation (CQRS) pattern. By leveraging Akka.NET for actor-based concurrency, FCQRS allows you to encapsulate aggregates within actors that process commands, generate events, and manage long-running business processes via sagas. The framework is designed to protect your core domain logic while providing the flexibility to evolve your read models independently.

## Table of Contents
1. [Introduction](#introduction)
2. [Purpose and Benefits of FCQRS](#purpose-and-benefits-of-fcqrs)
3. [Why CQRS and Event Sourcing?](#why-cqrs-and-event-sourcing)
4. [Key Features](#key-features)
   - [Abstraction of Akka.NET](#abstraction-of-akka-net)
   - [Command and Event Handling](#command-and-event-handling)
   - [Saga Implementation](#saga-implementation)
5. [Getting Started](#getting-started)
   - [Installation and Setup](#installation-and-setup)
   - [Basic Usage Example](#basic-usage-example)
6. [Live Coding Examples](#live-coding-examples)
7. [Advanced Topics](#advanced-topics)
   - [Event Sourcing Details](#event-sourcing-details)
   - [Handling Eventual Consistency](#handling-eventual-consistency)
   - [Best Practices](#best-practices)
8. [Use Cases](#use-cases)
   - [Real-World Scenarios](#real-world-scenarios)
   - [Case Studies](#case-studies)

## Introduction
FCQRS is designed to simplify the implementation of CQRS in F#. It integrates with Akka.NET, allowing developers to leverage the actor model for representing aggregates. This separation between command handling and query processing protects your core domain from changes that arise due to evolving reporting requirements.

## Purpose and Benefits of FCQRS
- **Separation of Concerns:** By isolating write operations (commands) from read operations (queries), FCQRS safeguards your core domain model from unnecessary changes.
- **Testability:** Command handlers, event handlers, and sagas can be independently developed and tested.
- **Scalability:** Utilizing Akka.NET’s actor model allows your system to handle a large number of concurrent operations efficiently.
- **Flexibility through Event Sourcing:** With event sourcing, every state change is logged, enabling features like versioning and rollback without altering the core data structure.

## Why CQRS and Event Sourcing?
The primary motivation behind adopting CQRS is the differing requirements of the read and write sides of an application:
- **Independent Evolution:** Query-side requirements tend to evolve (e.g., new reporting needs) while the write side—your core domain—remains stable.
- **Protecting the Core Domain:** By decoupling these responsibilities, changes in reporting or querying do not risk the integrity of your domain logic.
- **Comprehensive Change Tracking:** Event sourcing records every change as an event, enabling you to reconstruct state history and easily implement features such as versioning or rollbacks.

## Key Features

### Abstraction of Akka.NET
FCQRS abstracts away the complexities of Akka.NET, so you can focus on defining your aggregates as actors without needing to manage the low-level details of actor management.

### Command and Event Handling
- **Command Handlers:** Manage incoming commands and validate or transform them into events.
- **Event Handlers:** Process events generated by aggregates to update read models or trigger further actions.

### Saga Implementation
FCQRS supports sagas (process managers) that orchestrate long-running business processes. This separation allows your domain aggregates to remain free of side effects, improving testability and maintainability.

## Getting Started

### Installation and Setup
1. **Prerequisites:** .NET 9 SDK.
2. **Installation:** Add the FCQRS nuget package to your project using your preferred package manager.
3. **Configuration:** Set up a IConfiguration preferrably hocon but not necessarily. 

### Basic Usage Example
Below is a simple example demonstrating how to set up command and event handlers:

```fsharp
// Define a command for creating a document
type CreateDocumentCommand = { DocumentId: Guid; Content: string }

// Define an event that results from the command
type DocumentCreatedEvent = { DocumentId: Guid; Content: string }

// Command handler: processes the command and generates an event
let handleCreateDocument (command: CreateDocumentCommand) =
    // Process command (e.g., validation, business logic)
    { DocumentId = command.DocumentId; Content = command.Content }

// Event handler: handles the resulting event
let handleDocumentCreated (event: DocumentCreatedEvent) =
    // Update read model or perform side effects
    printfn "Document created with ID: %A" event.DocumentId