(**
---
title: Other documentation2
category: Other documentation
categoryindex: 1
index: 1
---
*)

(*** hide ***)
#load "../../references.fsx"
open System.IO
open Microsoft.Extensions.Configuration
open Hocon.Extensions.Configuration


(**
# FCQRS Documentation

FCQRS is a F#-based implementation of the Command Query Responsibility Segregation (CQRS) pattern. By leveraging Akka.NET for actor-based concurrency, FCQRS allows you to encapsulate aggregates within actors that process commands, generate events, and manage long-running business processes via sagas. The framework is designed to protect your core domain logic while providing the flexibility to evolve your read models independently.

## Introduction
FCQRS is designed to simplify the implementation of CQRS in F#. It integrates with Akka.NET, allowing developers to leverage the actor model for representing aggregates. This separation between command handling and query processing protects your core domain from changes that arise due to evolving reporting requirements.

## Why CQRS and Event Sourcing?

The primary motivation behind adopting CQRS is the differing requirements of the read and write sides of an application:

- **Independent Evolution:** Query-side requirements tend to evolve (e.g., new reporting needs) while the write side—your core domain—remains stable.
- **Protecting the Core Domain:** By decoupling these responsibilities, changes in reporting or querying do not risk the integrity of your domain logic.
- **Comprehensive Change Tracking:** Event sourcing records every change as an event, enabling you to reconstruct state history and easily implement features such as versioning or rollbacks.

## Key Features

### Abstraction of Akka.NET
FCQRS abstracts away the complexities of Akka.NET, so you can focus on defining your aggregates as actors without needing to manage the low-level details of actor management.

### Command and Event Handling
- **Command Handlers:** Manage incoming commands and validate or transform them into events.
- **Event Handlers:** Process events generated by aggregates to update read models or trigger further actions.

### Saga Implementation
FCQRS supports sagas (process managers) that orchestrate long-running business processes. This separation allows your domain aggregates to remain free of side effects, improving testability and maintainability.

## Getting Started

### Installation and Setup
1. **Prerequisites:** .NET 9 SDK.
2. **Packages:** Add the following nuget packages to your project using your preferred package manager:
   - `FCQRS`
   - `Hocon.Extensions.Configuration` (optional, for HOCON configuration)
   - `Microsoft.Extensions.Logging.Console` (optional, for logging)

## A Walkthrough: User Registration and Login
In this example, we will create a simple user registration and login system using FCQRS. The system will consist of a `User` aggregate that handles commands for registering and logging in users.
The aggregate will emit events based on the commands it processes. We will also implement a simple actor that will manage the state of the `User` aggregate.


1. **Create a new F# project:**
   dotnet new console -lang F# -n MyFCQRSApp
2. **Add the packages:** <br>
   dotnet add package FCQRS <br>
   dotnet add package Hocon.Extensions.Configuration <br>
   dotnet add package Microsoft.Extensions.Logging.Console <br>
3. **Create a hocon configuration file:** 
   [config.hocon](config.hocon)
4. **Create an Environments module and implement IConfiguration: and ILoggerFactory:**

*)

open Microsoft.Extensions.Configuration
open Microsoft.Extensions.Logging

type AppEnv(config: IConfiguration, loggerFactory: ILoggerFactory) =
    interface ILoggerFactory with
        member _.AddProvider(provider: ILoggerProvider) : unit = 
            loggerFactory.AddProvider provider

        member _.CreateLogger(categoryName: string) : ILogger =
            loggerFactory.CreateLogger categoryName 

        member _.Dispose() : unit = loggerFactory.Dispose()

    interface IConfiguration with
        member _.Item
            with get (key: string) = config.[key]
            and set key v = config.[key] <- v

        member _.GetChildren() = config.GetChildren()
        member _.GetReloadToken() = config.GetReloadToken()
        member _.GetSection key = config.GetSection key

(**

Above code acts as a composition root for the application environment. It wraps `IConfiguration` and `ILoggerFactory`, allowing you to manage configuration and logging in a clean and type-safe manner.
*)

(** 
### User Aggregate
The `User` aggregate is responsible for handling user registration and login commands. It maintains the state of the user, including the username and password.
*)

(** 
#### State, Command, and Event Types
*)

open FCQRS.Common

type State =
    { Username: string option
      Password: string option }

type Command =
    | Login of string
    | Register of string * string

type Event =
    | LoginSucceeded
    | LoginFailed
    | RegisterSucceeded of string * string
    | AlreadyRegistered

(**
For each aggregate, we define State, Command, and Event types. The `State` type represents the current state of the aggregate, while the `Command` type defines the commands that can be sent to the aggregate. The `Event` type defines the events that can be emitted by the aggregate.
*)
