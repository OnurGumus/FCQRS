<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FCQRS</name></assembly>
<members>
<member name="T:FCQRS.Common.PrefixConversion">
<summary>
 Default shard name used if no specific sharding strategy is provided.
 Represents a potential transformation to apply to an entity ID prefix, used in saga routing.
 Allows sagas to be co-located or routed differently based on the originator&apos;s ID structure.
</summary>
</member>
<member name="P:FCQRS.Common.IActor.TimeProvider">
<summary>
 Gets the time provider.
</summary>
</member>
<member name="P:FCQRS.Common.IActor.System">
<summary>
 Gets the hosting ActorSystem.
</summary>
</member>
<member name="P:FCQRS.Common.IActor.Mediator">
<summary>
 Gets the reference to the distributed pub/sub mediator actor.
</summary>
</member>
<member name="P:FCQRS.Common.IActor.Materializer">
<summary>
 Gets the Akka Streams materializer.
</summary>
</member>
<member name="P:FCQRS.Common.IActor.LoggerFactory">
<summary>
 Gets the logger factory.
</summary>
</member>
<member name="P:FCQRS.Common.IActor.Configuration">
<summary>
 Gets the configuration.
</summary>
</member>
<member name="M:FCQRS.Common.IActor.SubscribeForCommand``2(FCQRS.Common.CommandHandler.Command{``0,``1})">
<summary>
 Subscribes to the result of a command sent to another actor.
</summary>
</member>
<member name="M:FCQRS.Common.IActor.Stop">
<summary>
 Stops the actor system gracefully.
</summary>
</member>
<member name="M:FCQRS.Common.IActor.InitializeSagaStarter(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Collections.FSharpList{System.Tuple{Microsoft.FSharp.Core.FSharpFunc{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},FCQRS.Common.PrefixConversion,System.Object}}})">
<summary>
 Initializes the Saga Starter actor, configuring which events trigger which sagas.
 &lt;param name=&quot;eventHandler&quot;&gt;A function mapping a received event object to a list of saga definitions to start: `obj -&gt; list&lt;(Factory * Prefix * StartingEvent)&gt;`.&lt;/param&gt;
</summary>
</member>
<member name="M:FCQRS.Common.IActor.InitializeSaga``3(FCQRS.Common.SagaState{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.SagaState{``0,``1},FCQRS.Common.EventAction{``1}}},Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.SagaState{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpOption{FCQRS.Common.SagaStarter.SagaStartingEvent{FCQRS.Common.Event{``2}}},Microsoft.FSharp.Core.FSharpFunc{System.Boolean,System.Tuple{FCQRS.Common.SagaTransition{``1},Microsoft.FSharp.Collections.FSharpList{FCQRS.Common.ExecuteCommand}}}}},Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.SagaState{``0,``1},FCQRS.Common.SagaState{``0,``1}},System.String)">
<summary>
 Initializes a sharded, persistent saga actor.
 &lt;param name=&quot;initialState&quot;&gt;The initial state (`SagaState`) for new saga instances.&lt;/param&gt;
 &lt;param name=&quot;handleEvent&quot;&gt;The event handler function: `Event -&gt; SagaState -&gt; EventAction`.&lt;/param&gt;
 &lt;param name=&quot;applySideEffects&quot;&gt;Function determining side effects based on state transitions: `SagaState -&gt; Option&lt;StartingEvent&gt; -&gt; bool -&gt; SagaTransition&lt;NewState&gt; * ExecuteCommand list`.&lt;/param&gt;
 &lt;param name=&quot;applyStateChange&quot;&gt;Function to apply internal state changes: `SagaState -&gt; SagaState`.&lt;/param&gt;
 &lt;param name=&quot;name&quot;&gt;The shard type name for this saga.&lt;/param&gt;
 &lt;returns&gt;An entity factory (`EntityFac&lt;obj&gt;`) for creating instances of this saga.&lt;/returns&gt;
</summary>
</member>
<member name="M:FCQRS.Common.IActor.InitializeActor``3(``0,System.String,Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.Command{``1},Microsoft.FSharp.Core.FSharpFunc{``0,FCQRS.Common.EventAction{``2}}},Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.Event{``2},Microsoft.FSharp.Core.FSharpFunc{``0,``0}})">
<summary>
 Initializes a sharded, persistent aggregate actor.
 &lt;param name=&quot;cfg&quot;&gt;Environment configuration (IConfiguration &amp; ILoggerFactory).&lt;/param&gt;
 &lt;param name=&quot;initialState&quot;&gt;The initial state for new aggregate instances.&lt;/param&gt;
 &lt;param name=&quot;name&quot;&gt;The shard type name for this aggregate.&lt;/param&gt;
 &lt;param name=&quot;handleCommand&quot;&gt;The command handler function: `Command -&gt; State -&gt; EventAction`.&lt;/param&gt;
 &lt;param name=&quot;apply&quot;&gt;The event handler function: `Event -&gt; State -&gt; State`.&lt;/param&gt;
 &lt;returns&gt;An entity factory (`EntityFac&lt;obj&gt;`) for creating instances of this actor.&lt;/returns&gt;
</summary>
</member>
<member name="M:FCQRS.Common.IActor.CreateCommandSubscription``2(Microsoft.FSharp.Core.FSharpFunc{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},FCQRS.Model.Data.CID,FCQRS.Model.Data.AggregateId,``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Boolean},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Collections.FSharpMap{System.String,System.String}})">
<summary>
 Creates a command subscription to wait for a specific event from a target actor.
 Sends the command and asynchronously returns the first matching event received.
 &lt;param name=&quot;factory&quot;&gt;Entity factory function for the target actor type.&lt;/param&gt;
 &lt;param name=&quot;cid&quot;&gt;Correlation ID for tracking.&lt;/param&gt;
 &lt;param name=&quot;id&quot;&gt;Entity ID of the target actor.&lt;/param&gt;
 &lt;param name=&quot;command&quot;&gt;The command payload to send.&lt;/param&gt;
 &lt;param name=&quot;filter&quot;&gt;A predicate function to select the desired event.&lt;/param&gt;
 &lt;param name=&quot;metadata&quot;&gt;Optional metadata to include with the command.&lt;/param&gt;
 &lt;returns&gt;An async computation yielding the target event.&lt;/returns&gt;
</summary>
</member>
<member name="T:FCQRS.Common.IActor">
<summary>
 Defines the core functionalities and context provided by the FCQRS environment to actors.
 This interface provides access to essential Akka.NET services and FCQRS initialization methods.
</summary>
</member>
<member name="P:FCQRS.Common.SagaState`2.State">
<summary>
 The current state machine state of the saga.
</summary>
</member>
<member name="P:FCQRS.Common.SagaState`2.Data">
<summary>
 The custom data associated with this saga instance.
</summary>
</member>
<member name="T:FCQRS.Common.SagaState`2">
<summary>
 Represents the state of a saga instance.
 &lt;typeparam name=&quot;&apos;SagaData&quot;&gt;The type of the custom data held by the saga.&lt;/typeparam&gt;
 &lt;typeparam name=&quot;&apos;State&quot;&gt;The type representing the saga&apos;s current state machine state (e.g., an enum or DU).&lt;/typeparam&gt;
</summary>
</member>
<member name="T:FCQRS.Common.SagaTransition`1.NextState">
<summary>
 The saga should transition to a new state
</summary>
</member>
<member name="T:FCQRS.Common.SagaTransition`1.Stay">
<summary>
 The saga should stay in current state without changes
</summary>
</member>
<member name="T:FCQRS.Common.SagaTransition`1.StopSaga">
<summary>
 The saga should stop and terminate
</summary>
</member>
<member name="T:FCQRS.Common.SagaTransition`1">
<summary>
 Represents the next state transition for a saga after processing an event or timeout.
</summary>
</member>
<member name="P:FCQRS.Common.ExecuteCommand.DelayInMs">
<summary>
 An optional delay in milliseconds before sending the command.
</summary>
</member>
<member name="P:FCQRS.Common.ExecuteCommand.Command">
<summary>
 The command message to send (boxed).
</summary>
</member>
<member name="P:FCQRS.Common.ExecuteCommand.TargetActor">
<summary>
 The target actor for the command.
</summary>
</member>
<member name="T:FCQRS.Common.ExecuteCommand">
<summary>
 Represents a command to be executed, often scheduled or triggered by a saga.
</summary>
</member>
<member name="T:FCQRS.Common.TargetActor.Self">
<summary>
 Specifies the target as the current saga actor itself.
</summary>
</member>
<member name="T:FCQRS.Common.TargetActor.Sender">
<summary>
 Specifies the target as the original sender of the message that triggered the current saga step.
</summary>
</member>
<member name="T:FCQRS.Common.TargetActor.ActorRef">
<summary>
 Specifies the target using its direct IActorRef (usually boxed as obj).
</summary>
</member>
<member name="T:FCQRS.Common.TargetActor.FactoryAndName">
<summary>
 Specifies the target using a factory function and name.
</summary>
</member>
<member name="T:FCQRS.Common.TargetActor">
<summary>
 Represents the target of a command execution triggered by a saga.
</summary>
</member>
<member name="P:FCQRS.Common.FactoryAndName.Name">
<summary>
 The name identifier for the target actor.
</summary>
</member>
<member name="P:FCQRS.Common.FactoryAndName.Factory">
<summary>
 The factory function (or entity ref creator) used to potentially create the actor.
</summary>
</member>
<member name="T:FCQRS.Common.FactoryAndName">
<summary>
 Represents the information needed to locate or create a target actor, typically used within sagas.
</summary>
</member>
<member name="T:FCQRS.Common.TargetName.Originator">
<summary>
 Identify the target as the originator actor of the current saga process.
</summary>
</member>
<member name="T:FCQRS.Common.TargetName.Name">
<summary>
 Identify the target by its string name (entity ID).
</summary>
</member>
<member name="T:FCQRS.Common.TargetName">
<summary>
 Represents the name identifying a target actor for a command, typically used within sagas.
</summary>
</member>
<member name="T:FCQRS.Common.EventAction`1.StateChangedEvent">
<summary>
 Indicate that the state of a saga has changed (used internally by sagas for persistence).
</summary>
</member>
<member name="T:FCQRS.Common.EventAction`1.UnhandledEvent">
<summary>
 Indicate that the command or event could not be handled in the current state.
</summary>
</member>
<member name="T:FCQRS.Common.EventAction`1.IgnoreEvent">
<summary>
 Ignore the event or command completely. No persistence, publishing, or state update occurs.
</summary>
</member>
<member name="T:FCQRS.Common.EventAction`1.PublishEvent">
<summary>
 Publish the event immediately to the mediator without persisting it. The actor&apos;s state is not updated.
</summary>
</member>
<member name="T:FCQRS.Common.EventAction`1.DeferEvent">
<summary>
 Defer the event. It will be stashed and processed later, potentially after other events.
</summary>
</member>
<member name="T:FCQRS.Common.EventAction`1.PersistEvent">
<summary>
 Persist the event to the journal. The actor&apos;s state will be updated using the event handler *after* persistence succeeds.
</summary>
</member>
<member name="T:FCQRS.Common.EventAction`1">
<summary>
 Defines the possible actions an aggregate or saga actor can take after processing a command or event.
 &lt;typeparam name=&quot;&apos;T&quot;&gt;The type of the event payload associated with the action (e.g., for PersistEvent).&lt;/typeparam&gt;
</summary>
</member>
<member name="P:FCQRS.Common.Event`1.Metadata">
<summary>
 Metadata associated with the event.
</summary>
</member>
<member name="P:FCQRS.Common.Event`1.Version">
<summary>
 The version number of the aggregate after this event was applied.
</summary>
</member>
<member name="P:FCQRS.Common.Event`1.CorrelationId">
<summary>
 The correlation ID linking the event back to the originating command.
</summary>
</member>
<member name="P:FCQRS.Common.Event`1.Sender">
<summary>
 An optional identifier for the actor that generated the event.
</summary>
</member>
<member name="P:FCQRS.Common.Event`1.Id">
<summary>
 A unique identifier for the message.
</summary>
</member>
<member name="P:FCQRS.Common.Event`1.CreationDate">
<summary>
 The timestamp when the event was created.
</summary>
</member>
<member name="P:FCQRS.Common.Event`1.EventDetails">
<summary>
 The specific details or payload of the event.
</summary>
</member>
<member name="T:FCQRS.Common.Event`1">
<summary>
 Represents an event generated by an aggregate actor as a result of processing a command.
 &lt;typeparam name=&quot;&apos;EventDetails&quot;&gt;The specific type of the event payload.&lt;/typeparam&gt;
</summary>
</member>
<member name="P:FCQRS.Common.Command`1.Metadata">
<summary>
 Metadata associated with the command.
</summary>
</member>
<member name="P:FCQRS.Common.Command`1.CorrelationId">
<summary>
 The correlation ID used to track the command through the system.
</summary>
</member>
<member name="P:FCQRS.Common.Command`1.Sender">
<summary>
 An optional identifier for the actor that sent the command.
</summary>
</member>
<member name="P:FCQRS.Common.Command`1.Id">
<summary>
 A unique identifier for the message.
</summary>
</member>
<member name="P:FCQRS.Common.Command`1.CreationDate">
<summary>
 The timestamp when the command was created.
</summary>
</member>
<member name="P:FCQRS.Common.Command`1.CommandDetails">
<summary>
 The specific details or payload of the command.
</summary>
</member>
<member name="T:FCQRS.Common.Command`1">
<summary>
 Represents a command to be processed by an aggregate actor.
 &lt;typeparam name=&quot;&apos;CommandDetails&quot;&gt;The specific type of the command payload.&lt;/typeparam&gt;
</summary>
</member>
<member name="T:FCQRS.Common.ISerializable">
<summary>
 Marker interface for types that can be serialized by Akka.NET.
</summary>
</member>
<member name="M:FCQRS.Common.sameTrace(FCQRS.Model.Data.CID,FCQRS.Model.Data.CID)">
<summary>
 Compare two CIDs by their TraceId (for correlation in distributed tracing scenarios)
</summary>
</member>
<member name="M:FCQRS.Common.extractTraceId(FCQRS.Model.Data.CID)">
<summary>
 Helper to extract TraceId from a CID (W3C traceparent format: 00-{traceId}-{spanId}-{flags})
 Returns the full CID string if not in traceparent format
</summary>
</member>
<member name="T:FCQRS.Common.CommandHandler.Command`2">
<summary>
 Represents the message sent to the internal subscription mechanism.
 &lt;typeparam name=&quot;&apos;Command&quot;&gt;The type of the command payload.&lt;/typeparam&gt;
 &lt;typeparam name=&quot;&apos;Event&quot;&gt;The type of the expected event payload.&lt;/typeparam&gt;
</summary>
</member>
<member name="T:FCQRS.Common.CommandHandler">
<summary>
 (Internal) Contains the implementation for command subscriptions.
</summary>
</member>
<member name="P:FCQRS.Common.SagaStarter.SagaStartingEvent`1.Event">
<summary>
 The actual event payload that triggers the saga.
</summary>
</member>
<member name="T:FCQRS.Common.SagaStarter.SagaStartingEvent`1">
<summary>
 Wraps an event that is intended to start a saga.
 This is typically the message sent to a saga actor upon its creation.
 &lt;typeparam name=&quot;&apos;T&quot;&gt;The type of the starting event payload.&lt;/typeparam&gt;
</summary>
</member>
<member name="T:FCQRS.Common.SagaStarter">
<summary>
 Contains types and functions related to the Saga Starter actor (internal implementation detail).
</summary>
</member>
<member name="T:FCQRS.Common.SagaBuilder.SagaStateWrapper`2">
<summary>
 Standard wrapper for saga states that includes NotStarted/Started
</summary>
</member>
<member name="M:FCQRS.Common.SagaBuilder.initSimple``3(FCQRS.Common.IActor,``0,Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.SagaState{``0,Microsoft.FSharp.Core.FSharpOption{``1}},FCQRS.Common.EventAction{``1}}},Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.SagaState{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Boolean,System.Tuple{FCQRS.Common.SagaTransition{``1},Microsoft.FSharp.Collections.FSharpList{FCQRS.Common.ExecuteCommand}}}},Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.SagaState{``0,``1},FCQRS.Common.SagaState{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},System.String)">
<summary>
 Simplified saga initialization with unwrapped apply function
</summary>
</member>
<member name="M:FCQRS.Common.SagaBuilder.init``3(FCQRS.Common.IActor,``0,Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.SagaState{``0,Microsoft.FSharp.Core.FSharpOption{``1}},FCQRS.Common.EventAction{``1}}},Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.SagaState{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Boolean,System.Tuple{FCQRS.Common.SagaTransition{``1},Microsoft.FSharp.Collections.FSharpList{FCQRS.Common.ExecuteCommand}}}},Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.SagaState{``0,FCQRS.Common.SagaBuilder.SagaStateWrapper{``1,``2}},FCQRS.Common.SagaState{``0,FCQRS.Common.SagaBuilder.SagaStateWrapper{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},System.String)">
<summary>
 High-level saga initialization that handles all wrapping automatically
</summary>
</member>
<member name="M:FCQRS.Common.SagaBuilder.wrapApply``3(Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.SagaState{``0,``1},FCQRS.Common.SagaState{``0,``1}},FCQRS.Common.SagaState{``0,FCQRS.Common.SagaBuilder.SagaStateWrapper{``1,``2}})">
<summary>
 Wraps user&apos;s apply function to handle NotStarted/Started automatically
</summary>
</member>
<member name="M:FCQRS.Common.SagaBuilder.wrapHandleEvent``3(Microsoft.FSharp.Core.FSharpFunc{System.Object,Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.SagaState{``0,Microsoft.FSharp.Core.FSharpOption{``1}},FCQRS.Common.EventAction{``1}}},System.Object,FCQRS.Common.SagaState{``0,FCQRS.Common.SagaBuilder.SagaStateWrapper{``1,``2}})">
<summary>
 Wraps user&apos;s handleEvent to skip NotStarted but allow Started states
</summary>
</member>
<member name="M:FCQRS.Common.SagaBuilder.wrapApplySideEffects``3(Microsoft.FSharp.Core.FSharpFunc{FCQRS.Common.SagaState{``0,``1},Microsoft.FSharp.Core.FSharpFunc{System.Boolean,System.Tuple{FCQRS.Common.SagaTransition{``1},Microsoft.FSharp.Collections.FSharpList{FCQRS.Common.ExecuteCommand}}}},Microsoft.FSharp.Core.FSharpFunc{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},FCQRS.Common.SagaState{``0,FCQRS.Common.SagaBuilder.SagaStateWrapper{``1,``2}},Microsoft.FSharp.Core.FSharpOption{FCQRS.Common.SagaStarter.SagaStartingEvent{FCQRS.Common.Event{``2}}},System.Boolean)">
<summary>
 Wraps user&apos;s applySideEffects to handle NotStarted/Started automatically
</summary>
</member>
<member name="M:FCQRS.Common.SagaBuilder.createInitialState``3(``0)">
<summary>
 Creates initial saga state with NotStarted
</summary>
</member>
<member name="M:FCQRS.Common.SagaBuilder.handleStartedState``2(System.Boolean,Microsoft.FSharp.Core.FSharpOption{FCQRS.Common.SagaStarter.SagaStartingEvent{FCQRS.Common.Event{``0}}},Microsoft.FSharp.Core.FSharpFunc{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}})">
<summary>
 Standard recovery logic for Started state that all sagas should use
 Handles the version checking handshake with the originator aggregate
</summary>
</member>
<member name="T:FCQRS.Common.SagaBuilder">
<summary>
 Contains types and functions for building and initializing sagas
</summary>
</member>
<member name="T:FCQRS.Common">
 <summary>
  Contains common types like Events and Commands
 </summary>

 <namespacedoc>
   <summary>Functionality for Write Side.</summary>
 </namespacedoc>
</member>
<member name="M:FCQRS.DynamicConfig.ConfigExtension.GetSectionAsDynamic(Microsoft.Extensions.Configuration.IConfiguration,System.String)">
 <summary>
 An extension method that returns given string as an dynamic Expando object
 </summary>
 <exception cref="System.ArgumentNullException">Thrown configuration or section is null</exception>
</member>
<member name="M:FCQRS.DynamicConfig.ConfigExtension.GetRootAsDynamic(Microsoft.Extensions.Configuration.IConfiguration)">
 <summary>
 An extension method that returns given string as an dynamic Expando object
 </summary>
 <returns>An expando object represents given section</returns>
 <exception cref="System.ArgumentNullException">Thrown configuration is null</exception>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.remove_OnEnqueued(Microsoft.FSharp.Control.FSharpHandler{System.Tuple{Microsoft.FSharp.Core.FSharpOption{System.String},System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}}})">
<summary>
 Fired whenever a ScheduledItem is enqueued
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.remove_OnCancelled(Microsoft.FSharp.Control.FSharpHandler{System.Tuple{Microsoft.FSharp.Core.FSharpOption{System.String},System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}}})">
<summary>
 Fired whenever a ScheduledItem is cancelled
</summary>
</member>
<member name="P:FCQRS.Scheduler.ObservingScheduler.OnEnqueued">
<summary>
 Fired whenever a ScheduledItem is enqueued
</summary>
</member>
<member name="P:FCQRS.Scheduler.ObservingScheduler.OnCancelled">
<summary>
 Fired whenever a ScheduledItem is cancelled
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.add_OnEnqueued(Microsoft.FSharp.Control.FSharpHandler{System.Tuple{Microsoft.FSharp.Core.FSharpOption{System.String},System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}}})">
<summary>
 Fired whenever a ScheduledItem is enqueued
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.add_OnCancelled(Microsoft.FSharp.Control.FSharpHandler{System.Tuple{Microsoft.FSharp.Core.FSharpOption{System.String},System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit}}})">
<summary>
 Fired whenever a ScheduledItem is cancelled
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.ScheduleTellRepeatedly(System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
<summary>
 Fallback ScheduleTellRepeatedly without name
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.ScheduleTellRepeatedly(Microsoft.FSharp.Core.FSharpOption{System.String},System.TimeSpan,System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
<summary>
 Schedule repeated Tell with optional name
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.ScheduleTellOnce(System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
<summary>
 Fallback ScheduleTellOnce without name
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.ScheduleTellOnce(Microsoft.FSharp.Core.FSharpOption{System.String},System.TimeSpan,Akka.Actor.ICanTell,System.Object,Akka.Actor.IActorRef)">
<summary>
 Schedule a one-time Tell with optional name
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.ScheduleRepeatedly(System.TimeSpan,System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Fallback ScheduleRepeatedly without name
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.ScheduleRepeatedly(Microsoft.FSharp.Core.FSharpOption{System.String},System.TimeSpan,System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Schedule a repeated action with optional name
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.ScheduleOnce(System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Fallback ScheduleOnce without name
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.ScheduleOnce(Microsoft.FSharp.Core.FSharpOption{System.String},System.TimeSpan,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,Microsoft.FSharp.Core.Unit})">
<summary>
 Schedule a one-time action with optional name
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.Cancel(Akka.Actor.ICancelable,Microsoft.FSharp.Core.FSharpOption{System.String})">
<summary>
 Cancel via wrapper with name
</summary>
</member>
<member name="M:FCQRS.Scheduler.ObservingScheduler.Advance(System.TimeSpan)">
<summary>
 Drive the virtual clock forward
</summary>
</member>
<member name="T:FCQRS.Scheduler.ObservingScheduler">
<summary>
 Scheduler wrapper that exposes enqueue/cancel events with optional names
</summary>
</member>
<member name="T:FCQRS.Scheduler.NamedCancelable">
<summary>
 Proxy that carries a name through cancellation - uses a CancellationTokenSource to handle cancellation
</summary>
</member>
<member name="M:FCQRS.SchedulerController.stop">
 <summary>
 (Optional) Stops the scheduler controller agent.
 </summary>
</member>
<member name="M:FCQRS.SchedulerController.registerAutoAdvanceOnAppearance(System.String)">
 <summary>
 Registers a task for automatic advancement upon its appearance.
 </summary>
</member>
<member name="M:FCQRS.SchedulerController.signalAndAdvanceForCapturedTask">
 <summary>
 Signals the controller to advance for a previously captured task and resume normal advancement.
 </summary>
</member>
<member name="M:FCQRS.SchedulerController.watchForAndPauseOnNext(System.String)">
 <summary>
 Instructs the controller to watch for the next occurrence of a specific task name.
 </summary>
</member>
<member name="M:FCQRS.SchedulerController.start(Akka.Actor.IScheduler)">
 <summary>
 Initializes and starts the SchedulerController agent.
 This should be called once during application startup.
 </summary>
</member>
<member name="T:FCQRS.Actor.Connection">
<summary>
 Represents a database connection configuration
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.DB2">
<summary>
 IBM DB2
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.Firebird">
<summary>
 Firebird
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.Oracle">
<summary>
 Oracle Database
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.MySql">
<summary>
 MySQL using MySqlConnector
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.PostgreSQL15">
<summary>
 PostgreSQL 15+
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.PostgreSQL">
<summary>
 PostgreSQL 9.3+
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.SqlServer2022">
<summary>
 Microsoft SQL Server 2022
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.SqlServer2019">
<summary>
 Microsoft SQL Server 2019
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.SqlServer2017">
<summary>
 Microsoft SQL Server 2017
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.SqlServer2016">
<summary>
 Microsoft SQL Server 2016
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.SqlServer2014">
<summary>
 Microsoft SQL Server 2014
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.SqlServer2012">
<summary>
 Microsoft SQL Server 2012
</summary>
</member>
<member name="T:FCQRS.Actor.DBType.Sqlite">
<summary>
 SQLite using Microsoft.Data.Sqlite provider
</summary>
</member>
<member name="T:FCQRS.Actor.DBType">
<summary>
 Represents the type of database connection
</summary>
</member>
<member name="T:FCQRS.Actor.HoconStringConfigurationSource">
<summary>
 Custom configuration source for in-memory HOCON strings
</summary>
</member>
<member name="T:FCQRS.Actor.HoconStringConfigurationProvider">
<summary>
 Custom configuration provider for in-memory HOCON strings
</summary>
</member>
<member name="M:FCQRS.Query.ISubscribe`1.Subscribe(FCQRS.Model.Data.CID,Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},System.Int32,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>
 Subscribes to events matching a specific correlation ID and an additional filter.
 </summary>
 <param name="cid">The correlation ID to match.</param>
 <param name="filter">Additional predicate to filter events after CID matching.</param>
 <param name="take">Maximum number of events to process.</param>
 <param name="callback">Optional callback function to handle the event.</param>
 <param name="cancellationToken">An optional cancellation token to cancel the subscription.</param>
</member>
<member name="M:FCQRS.Query.ISubscribe`1.Subscribe(FCQRS.Model.Data.CID,System.Int32,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>
 Subscribes to events matching a specific correlation ID.
 </summary>
 <param name="cid">The correlation ID to match.</param>
 <param name="take">Maximum number of events to process.</param>
 <param name="callback">Optional callback function to handle the event.</param>
 <param name="cancellationToken">An optional cancellation token to cancel the subscription.</param>
</member>
<member name="M:FCQRS.Query.ISubscribe`1.Subscribe(Microsoft.FSharp.Core.FSharpFunc{`0,System.Boolean},System.Int32,Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>
 Subscribes to events using a filter. Only events for which the predicate returns true
 are processed, and the callback is invoked for each matching event up to a specified count.
 </summary>
 <param name="filter">
 Predicate function to determine if an event should be processed, e.g.
 <c>fun event -> event.CorrelationId = targetId</c>.
 </param>
 <param name="take">Maximum number of events to process.</param>
 <param name="callback">
 Optional callback function to handle the event (defaults to ignoring the event if not provided).
 </param>
 <param name="cancellationToken">An optional cancellation token to cancel the subscription.</param>
 <example>
 <code lang="fsharp">
 // Typical usage: subscribe for a filtered event by matching on CorrelationId,
 // process only one event, and omit the callback and cancellation token.
 async {
     let targetId = some-correlation-id
     // Here, take is set to 1 and no callback or cancellation token is provided.
     let! subscription = query.Subscribe((fun event -> event.CorrelationId = targetId), 1)
     // Use the asynchronous subscription as needed.
 } |> Async.Start
 </code>
 </example>
</member>
<member name="M:FCQRS.Query.ISubscribe`1.Subscribe(Microsoft.FSharp.Core.FSharpFunc{`0,Microsoft.FSharp.Core.Unit},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
 <summary>
 Subscribes to all events and invokes the specified callback for each event.
 </summary>
 <param name="callback">Function invoked for each event, e.g. printing or processing the event.</param>
 <param name="cancellationToken">An optional cancellation token to cancel the subscription.</param>
 <example>
 <code lang="fsharp">
 // Example usage: subscribe to all events and write them to the console.
 let subscription =
     query.Subscribe((fun event -> printfn "Received event: %A" event))

 // Later, to cancel the subscription:
 subscription.Dispose()
 </code>
 </example>
</member>
<member name="M:FCQRS.CSharp.SagaBuilderCSharp.InitSimple``3(FCQRS.Common.IActor,``1,System.Func{FCQRS.Common.Event{``0},``1,``2,FCQRS.Common.EventAction{``2}},System.Func{``1,``2,System.Boolean,FCQRS.CSharp.SagaSideEffectResult{``2}},System.Func{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},System.String)">
<summary>
 Initialize a saga with simplified signatures and no apply
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaBuilderCSharp.InitSimple``3(FCQRS.Common.IActor,``1,System.Func{FCQRS.Common.Event{``0},``1,``2,FCQRS.Common.EventAction{``2}},System.Func{``1,``2,System.Boolean,FCQRS.CSharp.SagaSideEffectResult{``2}},System.Func{``1,``2,``1},System.Func{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},System.String)">
<summary>
 Initialize a saga with simplified signatures - no FSharpOption, typed events
 handleEvent: (event, data, currentState) -&gt; EventAction
 applySideEffects: (data, state, recovering) -&gt; SagaSideEffectResult
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaBuilderCSharp.Init``3(FCQRS.Common.IActor,``1,System.Func{System.Object,FCQRS.Common.SagaState{``1,Microsoft.FSharp.Core.FSharpOption{``2}},FCQRS.Common.EventAction{``2}},System.Func{FCQRS.Common.SagaState{``1,``2},System.Boolean,FCQRS.CSharp.SagaSideEffectResult{``2}},System.Func{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},System.String)">
<summary>
 Initialize a saga without apply (no data updates based on state)
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaBuilderCSharp.Init``3(FCQRS.Common.IActor,``1,System.Func{System.Object,FCQRS.Common.SagaState{``1,Microsoft.FSharp.Core.FSharpOption{``2}},FCQRS.Common.EventAction{``2}},System.Func{FCQRS.Common.SagaState{``1,``2},System.Boolean,FCQRS.CSharp.SagaSideEffectResult{``2}},System.Func{``1,``2,``1},System.Func{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},System.String)">
<summary>
 Initialize a saga with simplified apply - just takes data and unwrapped state, returns new data
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaBuilderCSharp.Init``3(FCQRS.Common.IActor,``1,System.Func{System.Object,FCQRS.Common.SagaState{``1,Microsoft.FSharp.Core.FSharpOption{``2}},FCQRS.Common.EventAction{``2}},System.Func{FCQRS.Common.SagaState{``1,``2},System.Boolean,FCQRS.CSharp.SagaSideEffectResult{``2}},System.Func{FCQRS.Common.SagaState{``1,FCQRS.Common.SagaBuilder.SagaStateWrapper{``2,``0}},FCQRS.Common.SagaState{``1,FCQRS.Common.SagaBuilder.SagaStateWrapper{``2,``0}}},System.Func{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},System.String)">
<summary>
 Initialize a saga with C# delegates
 &apos;TEvent - The triggering event type (from the originator aggregate)
 &apos;TSagaData - Cross-cutting saga data
 &apos;TSagaState - User-defined saga states
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaBuilderCSharp.Factory(FCQRS.Common.IActor,Akkling.Cluster.Sharding.EntityFac{System.Object},System.String)">
<summary>
 Get the factory for a saga
</summary>
</member>
<member name="T:FCQRS.CSharp.SagaBuilderCSharp">
<summary>
 C#-friendly saga builder
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaCommands.ToOriginatorDelayed(System.Func{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},System.Object,System.Int64,System.String)">
<summary>
 Create a delayed command
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaCommands.ToOriginator(System.Func{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},System.Object)">
<summary>
 Create a command to send to the originator aggregate
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaCommands.ToAggregate(System.Func{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},System.String,System.Object)">
<summary>
 Create a command to send to a named aggregate
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaCommands.ToActor(Akkling.ActorRefs.IActorRef{System.Object},System.Object)">
<summary>
 Create a command to send to an actor ref
</summary>
</member>
<member name="T:FCQRS.CSharp.SagaCommands">
<summary>
 C#-friendly saga command targeting
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaEventActions.Unhandled``1">
<summary>
 Event was not handled
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaEventActions.StateChanged``1(``0)">
<summary>
 Create a state change event
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaEventActions.Ignore``1">
<summary>
 Ignore the event
</summary>
</member>
<member name="T:FCQRS.CSharp.SagaEventActions">
<summary>
 C#-friendly factory methods for saga EventAction
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaTransitions.StopSaga``1">
<summary>
 Stop the saga (completes the saga lifecycle)
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaTransitions.Stay``1">
<summary>
 Stay in the current state (no transition)
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaTransitions.NextState``1(``0)">
<summary>
 Transition to a new state
</summary>
</member>
<member name="T:FCQRS.CSharp.SagaTransitions">
<summary>
 C#-friendly factory methods for SagaTransition
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaStates.WithState``2(FCQRS.Common.SagaState{``0,``1},``1)">
<summary>
 Create a new SagaState with updated State
</summary>
</member>
<member name="M:FCQRS.CSharp.SagaStates.WithData``2(FCQRS.Common.SagaState{``0,``1},``0)">
<summary>
 Create a new SagaState with updated Data
</summary>
</member>
<member name="T:FCQRS.CSharp.SagaStates">
<summary>
 C#-friendly helpers for SagaState
</summary>
</member>
<member name="P:FCQRS.CSharp.SagaSideEffectResult`1.CommandsList">
<summary>
 Convert commands to F# list for internal use
</summary>
</member>
<member name="T:FCQRS.CSharp.SagaSideEffectResult`1">
<summary>
 C#-friendly result type for saga side effects (uses class for C# object initializer syntax)
</summary>
</member>
<member name="M:FCQRS.CSharp.ISubscribeExtensions.SubscribeFor``1(FCQRS.Query.ISubscribe{``0},System.Func{``0,System.Boolean},System.Int32)">
<summary>
 C#-friendly Subscribe that accepts Func instead of FSharpFunc
</summary>
</member>
<member name="T:FCQRS.CSharp.ISubscribeExtensions">
<summary>
 Extension methods for ISubscribe
</summary>
</member>
<member name="M:FCQRS.CSharp.IActorExtensions.SendCommandAsync``2(FCQRS.Common.IActor,System.Func{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},FCQRS.Model.Data.CID,FCQRS.Model.Data.AggregateId,``1,System.Func{``0,System.Boolean})">
<summary>
 Send a command and wait for the event (C# friendly)
</summary>
</member>
<member name="M:FCQRS.CSharp.IActorExtensions.InitializeSagaStarterEmpty(FCQRS.Common.IActor)">
<summary>
 Initialize saga starter with no sagas (for simple scenarios)
</summary>
</member>
<member name="M:FCQRS.CSharp.IActorExtensions.InitSagaStarterEmpty(FCQRS.Common.IActor)">
<summary>
 Static helper for C# where extension may not resolve
</summary>
</member>
<member name="M:FCQRS.CSharp.IActorExtensions.InitSagaStarter(FCQRS.Common.IActor,System.Func{System.Object,System.Collections.Generic.IList{FCQRS.CSharp.SagaDefinition}})">
<summary>
 C#-friendly InitializeSagaStarter that accepts Func returning IList of SagaDefinition
</summary>
</member>
<member name="M:FCQRS.CSharp.IActorExtensions.InitActor``3(FCQRS.Common.IActor,``0,System.String,System.Func{FCQRS.Common.Command{``1},``0,FCQRS.Common.EventAction{``2}},System.Func{FCQRS.Common.Event{``2},``0,``0})">
<summary>
 C#-friendly InitializeActor that accepts Func delegates instead of F# functions
</summary>
</member>
<member name="M:FCQRS.CSharp.IActorExtensions.CreateCommand``2(FCQRS.Common.IActor,System.Func{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}},FCQRS.Model.Data.CID,FCQRS.Model.Data.AggregateId,``1,System.Func{``0,System.Boolean})">
<summary>
 C#-friendly CreateCommandSubscription that returns FSharpAsync (for use with Handler delegate)
</summary>
</member>
<member name="T:FCQRS.CSharp.IActorExtensions">
<summary>
 Extension methods for IActor
</summary>
</member>
<member name="M:FCQRS.CSharp.QueryApi.InitWithList(FCQRS.Common.IActor,System.Int32,System.Func{System.Int64,System.Object,System.Collections.Generic.IList{FCQRS.Model.Data.IMessageWithCID}})">
<summary>
 Initialize the query subscription (C# IList version - converts to F# list internally)
</summary>
</member>
<member name="M:FCQRS.CSharp.QueryApi.Init(FCQRS.Common.IActor,System.Int32,System.Func{System.Int64,System.Object,Microsoft.FSharp.Collections.FSharpList{FCQRS.Model.Data.IMessageWithCID}})">
<summary>
 Initialize the query subscription (F# list version)
</summary>
</member>
<member name="T:FCQRS.CSharp.QueryApi">
<summary>
 C#-friendly Query API
</summary>
</member>
<member name="M:FCQRS.CSharp.ActorApi.Create(Microsoft.Extensions.Configuration.IConfiguration,Microsoft.Extensions.Logging.ILoggerFactory,System.String,System.String)">
<summary>
 Create the actor system with SQLite connection
</summary>
</member>
<member name="T:FCQRS.CSharp.ActorApi">
<summary>
 C#-friendly Actor API
</summary>
</member>
<member name="P:FCQRS.CSharp.PrefixConversions.Identity">
<summary>
 Identity conversion - uses originator prefix with saga suffix
 This creates saga IDs like: originatorId~Saga~correlationId
</summary>
</member>
<member name="M:FCQRS.CSharp.PrefixConversions.Custom(System.Func{System.String,System.String})">
<summary>
 Custom conversion function
</summary>
</member>
<member name="T:FCQRS.CSharp.PrefixConversions">
<summary>
 C#-friendly factory for PrefixConversion
</summary>
</member>
<member name="F:FCQRS.CSharp.SagaDefinition.StartingEvent@">
<summary>
 The event to send to start the saga
</summary>
</member>
<member name="F:FCQRS.CSharp.SagaDefinition.PrefixConversion@">
<summary>
 How to derive saga entity ID from source entity ID
</summary>
</member>
<member name="F:FCQRS.CSharp.SagaDefinition.Factory@">
<summary>
 Factory function to create entity reference from entity ID
</summary>
</member>
<member name="P:FCQRS.CSharp.SagaDefinition.StartingEvent(System.Object)">
<summary>
 The event to send to start the saga
</summary>
</member>
<member name="P:FCQRS.CSharp.SagaDefinition.PrefixConversion(FCQRS.Common.PrefixConversion)">
<summary>
 How to derive saga entity ID from source entity ID
</summary>
</member>
<member name="P:FCQRS.CSharp.SagaDefinition.Factory(System.Func{System.String,Akkling.Cluster.Sharding.IEntityRef{System.Object}})">
<summary>
 Factory function to create entity reference from entity ID
</summary>
</member>
<member name="P:FCQRS.CSharp.SagaDefinition.StartingEvent">
<summary>
 The event to send to start the saga
</summary>
</member>
<member name="P:FCQRS.CSharp.SagaDefinition.PrefixConversion">
<summary>
 How to derive saga entity ID from source entity ID
</summary>
</member>
<member name="P:FCQRS.CSharp.SagaDefinition.Factory">
<summary>
 Factory function to create entity reference from entity ID
</summary>
</member>
<member name="T:FCQRS.CSharp.SagaDefinition">
<summary>
 C#-friendly class for defining saga starters (uses class for C# object initializer syntax)
</summary>
</member>
<member name="M:FCQRS.CSharp.EventActions.Persist``1(``0)">
<summary>
 Create a PersistEvent action (event will be persisted and published)
</summary>
</member>
<member name="M:FCQRS.CSharp.EventActions.Ignore``1">
<summary>
 Create an IgnoreEvent action (command is ignored, no event produced)
</summary>
</member>
<member name="M:FCQRS.CSharp.EventActions.Defer``1(``0)">
<summary>
 Create a DeferEvent action (event is returned but not persisted - for errors/rejections)
</summary>
</member>
<member name="T:FCQRS.CSharp.EventActions">
<summary>
 C#-friendly factory methods for EventAction
</summary>
</member>
<member name="M:FCQRS.CSharp.StringTypes.TryCreateShortString(System.String,FCQRS.Model.Data.ShortString@)">
<summary>
 Try to create a ShortString, returns (success, value, errorMessage)
</summary>
</member>
<member name="M:FCQRS.CSharp.StringTypes.TryCreateLongString(System.String,FCQRS.Model.Data.LongString@)">
<summary>
 Try to create a LongString, returns (success, value, errorMessage)
</summary>
</member>
<member name="T:FCQRS.CSharp.StringTypes">
<summary>
 C#-friendly string type creation with simple error handling
</summary>
</member>
<member name="M:FCQRS.CSharp.Results.Ok``2(``0)">
<summary>
 Create a successful result
</summary>
</member>
<member name="M:FCQRS.CSharp.Results.Error``2(``1)">
<summary>
 Create an error result
</summary>
</member>
<member name="T:FCQRS.CSharp.Results">
<summary>
 C#-friendly factory methods for FSharpResult
</summary>
</member>
<member name="M:FCQRS.CSharp.Helpers.TryCreateShortString(System.String)">
<summary>
 Try to create a ShortString (returns Result instead of throwing)
</summary>
</member>
<member name="M:FCQRS.CSharp.Helpers.TryCreateLongString(System.String)">
<summary>
 Try to create a LongString (returns Result instead of throwing)
</summary>
</member>
<member name="M:FCQRS.CSharp.Helpers.NewCID">
<summary>
 Create a new CID from a GUID v7
</summary>
</member>
<member name="M:FCQRS.CSharp.Helpers.CreateShortString(System.String)">
<summary>
 Create a ShortString from a string (throws on failure)
</summary>
</member>
<member name="M:FCQRS.CSharp.Helpers.CreateLongString(System.String)">
<summary>
 Create a LongString from a string (throws on failure)
</summary>
</member>
<member name="M:FCQRS.CSharp.Helpers.CreateCID(System.String)">
<summary>
 Create a CID from a string (throws on failure)
</summary>
</member>
<member name="M:FCQRS.CSharp.Helpers.CreateAggregateId(System.String)">
<summary>
 Create an AggregateId from a string (throws on failure)
</summary>
</member>
<member name="T:FCQRS.CSharp.Helpers">
<summary>
 Helper methods for creating FCQRS types from C#
</summary>
</member>
<member name="M:FCQRS.CSharp.AsyncExtensions.ToTask``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Static helper to convert Async to Task (for C# where extension may not resolve)
</summary>
</member>
<member name="M:FCQRS.CSharp.AsyncExtensions.AsTask``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Convert Async to Task
</summary>
</member>
<member name="T:FCQRS.CSharp.AsyncExtensions">
<summary>
 Extension methods for Async to make it easier to use from C#
</summary>
</member>
<member name="T:FCQRS.CSharp.Handler`2">
<summary>
 C# delegate for command handlers - returns Task&lt;Event&lt;TEvent&gt;&gt;
</summary>
</member>
<member name="T:FCQRS.CSharp">
<summary>
 C# interoperability helpers for FCQRS
 Provides simpler APIs for consuming FCQRS from C#
</summary>
</member>
</members>
</doc>
